<!doctype html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="widistillh=device-widistillh, initial-scale=1">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <title>3. 加法合成</title> 

    <script src="template.v2.js"></script>
</head>

<body>    
    <distill-header></distill-header>
    <d-title>
        <h1>3. 加法合成</h1>
    </d-title>
<d-article>
    <p>
        加法合成器通过生成和修改一大量的分音——拥有不同的幅度、频率以及相位（有时）—— 并且将它们加起来得到最终的声音。
        加法合成器是一种最自然和最直接的合成方法，然后由于它需要大量的参数（所有的幅度、频率以及相位值等），因此不是那么常见。
        开发一种使用起来不乏味的加法合成器并不容易。
        与其他技术相比，加法合成器中对所有这些正弦波进行求和，带来的高计算成本也限制了它的可用性。
    </p>

    <h2>3.1 加法合成器的历史</h2>
    <p>
        由于加法合成器的原理简单，很容易成为最古老的音乐合成形式。
        如果我们放宽它的定义，允许将累加正弦波之外的其他行驶，它的历史可以追溯到更远的时间。
    </p>
    <p>
        管风琴制造商早就了解到，同时演奏多个管道对一个音符的影响，每个音符都有自己的一组分音，以产生最终的混合声音。 
        管风琴通常被组织为一组管道（或 stop ），每个音符一组，这可以产生具有特定音色的音符。 
        如 Figure-18 所示，stop 有许多不同的形状，由不同的材料制成，特别是钢和木头。
        特定种类的完整的一组 stop, 一个音符对应一组，被称为管风琴的级（ rank ） 。 
    </p>
    <p><d-figure><img src="images/figure_18.png" alt="Figure 18" width="30%" /></d-figure> </p>
    <p>
        高级的管风琴有许多的级（ rank ）。
        管风琴在演奏一个音符的时，为了从一个级中选择一个Stop，需要拔出类似拉杆或者旋钮的控制装置。
        通过拔出合适的拉杆，管风琴可以立刻为了同一个音符演奏许多级的声音；事实上一些 rank 设计上就是同时奏响多个同级的管道，用来响应单独一个音符的演奏（用管风琴的术语来说，这个概念叫做混合）。
        如果你想大力出奇迹，同时演奏所有 rank 的声音，只需要拔出所有拉杆：用管风琴的话说就是“ to pull out all the stops ”。
    </p>

    <p>
        早期的机电合成器大都是加法合成器，主要使用的是音调轮（或者其他类似的装置）。
        音调轮最初由 Hermann von Helmholtz 设计发明，后续由 Rudolf Koenig 进行改进（Figure-19），这是一种带齿的金属圆盘装或者鼓装的装置。
        音调轮旁边固定放置一电磁线圈，当音调轮匀速旋转的时候，金属轮边缘的齿状外缘（Figure-20）会反复靠近或者远离磁场，
        这会产生一个变化的感应电流，进而生成一个波动的电信号
        <d-footnote id="1">
            这个电磁感应的原理与电吉他中的拾音器类似。
        </d-footnote>。
        我们可以通过把单个的音调轮的声音混合起来，制作一个简单的加法合成器。
    </p>

    <p><d-figure><img src="images/figure_19.png" alt="Figure 19" width="30%" /></d-figure> </p>
    <p><d-figure><img src="images/figure_20.png" alt="Figure 20" width="30%" /></d-figure> </p>    
    <p>
        历史上第一个出名的音乐合成器，是由 Thaddeus Cahill 出品的电风琴（Telharmonium ），该款产品使用了累加音调轮的方法，因此可以算作一种加法合成器。
        这个电风琴的背后的想法是，一个演奏者可以产生一个歌曲的电信号，这个电信号可以通过立刻通过广播或者电话线传到广大的听众哪里。
        Figure-21 描述的就是 Telharmonium 当时的辉煌，包括左下角的音调轮。
    </p>
    <p><d-figure><img src="images/figure_21.png" alt="Figure 21" width="80%" /></d-figure> </p>    

    <p>
        音调轮后来也形成了 Hammond Organ 公司特有的声音生成装置（伴随着该公司著名的 Leslie 旋转式扬声器），原理上还是加法合成器。
        Hammond Organ 管风琴有九个拉杆，它们指定了九个特定分音的幅度，频率范围从低于基音一个八度到高于三个八度。 
        这些拉杆与产生最终声音的音调轮相连。
    </p>
    <p><d-figure><img src="images/figure_22.png" alt="Figure 22" width="30%" /></d-figure> </p>   
    <p>
        一直到了数字时代，才开始有更多的加法合成器方面的尝试。
        1974年，Rocky Mount Instruments（RMI）公司生产的 Harmonic 合成器，也是式采用数字振荡器的第一款加法合成的电子音乐合成器。
        贝尔实验室的数字合成器，也是完全的加法合成，这款数字合成器还是当时业界影响巨大的试验性的产品。
        Fairlight Qasar 公司的 M8 合成器通过生成分音幅度的数据，再通过反傅里叶变换来生成最后的声音（参考12章）。
        M8 这款产品最后也取得了很好的商业上的成功，但还是非常昂贵。
        新英格兰公司的 Digital Synclavier II 产品也带有加法合成功能，包括其他合成方法（采样，FM 合成），
        其中加法合成是给专业的音乐工作室使用的。
    </p>
    
    <p>
        在1980年代和1990年代，Kawai 是主要的加法合成器生产厂商。
        Kawai 公司的K3，K5，以及后续大幅改进的 K5000 系列，在音乐家之间广泛使用。
        从1990年代开始，加法合成方法开始淡出商业硬件合成器，越来越多的出现在了软件合成器当中。
        这些软件合成器包括有：AIR Music Technology 公司的 Loom，Native Instruments 公司的 Razor,
        Image-Line 公司的 Harmor, 以及 Camel Audio 公司（后被苹果公司收购）的 Alchemy 产品。
    </p>
    <p><d-figure><img src="images/figure_23.png" alt="Figure 23" width="30%" /></d-figure> </p>   

    <h2>3.2 加法合成器的 </h2>
    
    <p>
        在加法合成器中，每一个时间步下都会维护修改分音的阵列，一个阵列在合成组件内生成一个单独声音。
        声音合成组件通常通过将阵列中的每个分音交给相应的正弦波发生器来生成各自的音频样本，
        正弦波发生器通过正弦函数来生成某个分音下的音频数据。
        然后将所有分音下的样本值相加以产生最终音频样本。
    </p>
    <p><d-figure><img src="images/figure_24.png" alt="Figure 24" width="70%" /></d-figure> </p>
    <p>
        Figure-24 显示了一种可能的加法合成器实现流程图。这当然不是唯一的实现方法，但它包含许多常见元素的示例：
    </p>
    <li><b>分音生成器</b></li>
    <p>
        这是分音的数据来源，他可以是任何函数或者采样。
        例如，生成器可能会输出几个预设的分音数组之一，这些预设数组旨在产生特定的音调。
        分音生成器还可以随时间修改分音对应的阵列。
        比如，一个分音生成器可以生成128组不同的分音阵列，具体选用哪组分音阵列发声，可以交给外部的参数控制。
        这与稍后讨论的称为波表合成的技术密切相关。
    </p>

    <li><b>分音修正器</b></li>
    <p>
        这个组件主要获得分音的阵列之后，进行调整和修改，再传输出去。
        一种最简单的修正器只是将所有分音的幅值乘以一个常数，起到一个频域放大的作用，或者只修改某些指定频率的分音。
    </p>
    
    <p>
        另外一种常见的修正器是滤波器，通过滤波函数形状对分音乘以不同的系数，来调整分音的幅度形状，如 Figure-25 所示。
        除了常见的滤波器之外，滤波器函数的形状有很多种类型。
        举例来说，低通滤波器裁剪掉高于某个频率值的分音幅度，高通滤波器压制低频部分。Figure-25 中显示的是高通滤波器。
        还有带通滤波器，保留某个频率范围内的分音，裁剪掉范围之外的，陷波滤波器则执行相反的操作。
        加法合成中另一个常见的滤波器是共振峰滤波器，其中分音的幅度被整形以模拟人类声道的效果。
    </p>
    
    <p><d-figure><img src="images/figure_25.png" alt="Figure 25" width="80%" /></d-figure> </p>
    
    <p>
        在时域而非频域中工作的其他合成方法中，滤波器的实现可能很棘手：实际上，第 7 章的所有内容都讨论了这些类型的滤波器。 
        但是对于加法合成器，幸运的是比较简单，因为在频域中，滤波器只不过是一个操纵部分数组的函数。
    </p>

    <li><b>分音组合器</b></li>
    <p>
        分音组合器，将两个或者多个分音阵列合并为一个单独的分音的阵列。
        假如分音是谐波的，每个阵列都包含相同的频率成分，那么这个操作就是简单将不同的阵列按相同的频率相加即可，这是加法版本的混合。
        假如说分音阵列有指定的频率成分，那么需要重新生一个新的相同大小的阵列，这时候需要一些技巧性的方法来压制频率。
        举例来说，你可以把所有频率排列在一起，然后去除最高的频率部分，确保分音阵列大小不变。
    </p>

    <li><b>分音调制器</b></li>
    <p>
        在这个组件中，分音发生器、修正器和组合器的参数可以通过自动或音乐家手动的调制过程进行实时更改。 
        调制信号通常从-1变化到1，或者可能从0变化到1。
        调制器不仅可以用于改变上述模块的参数，还可以用于改变其他调制器的参数。 
        两种常见的自动调制器是：
    </p>
    <p>
        <b>低频振荡器：</b> 让信号以音乐家指定的特定速率上下波动
    </p>
    <p>
        <b>封调器：</b> 按下键后，封调会随时间改变信号。 
        例如，在 ADSR 封调中，当您按下一个音符时，包络开始在一个起音时间的过程中从 0 上升到某个起音电平。
        当它达到起音电平时，它开始在衰减时间的过程中下降到某个维持水平。 
        当它达到延音电平时，它会一直停留在那里，直到您释放琴键，此时它会在释放时间的过程中开始衰减到零。 
        在演奏的时候，音乐家会指定这些值的大小。
    </p>
    
    <p>
        调制对于制作逼真的声音绝对至关重要。试想一下，当有人演奏小号之类的乐器时，我们通常会先听到一阵响亮而粗暴的喇叭声，然后逐渐减弱为柔和的音调。
        这里发生了两件事。首先，喇叭开始响亮，然后音量迅速下降。
        其次，小号以大量的高频泛音开始，给人一种刺耳而嗡嗡的声音，然后迅速减少到只有低频泛音，从而使音调变得圆润。
        如果我们想模拟这一点，我们会使用调制程序，当播放一个音符时，声音会变大，可能会打开一个低通滤波器以允许更高的谐波通过，然后很快就会使声音变得安静并关闭很多滤波器（切除高次谐波）。
        这种调制过程需要一个或多个封调。
        同样，如果我们希望添加振音（快速上下移动音量）或颤音（快速上下移动音高）或其他振荡效果，我们可以使用 LFO。
    </p>

    <p>
        其他调制功能包括：琶音和序列器，我们会在第四章覆盖更多的细节。
    </p>

    <h2>3.3 加法合成器的实现 </h2>
    <p>
        加法合成器可以直接实现为一组模块，这些模块相互之间传递分音阵列或单独某一个调制值。 
        每隔一段时间，代码会按顺序更新所有模块，允许它们从其他模块中提取最新信息，以便修改自己提供的分音阵列或调制值。 
        最后一个模块 Out 将提取并保存最新的分音阵列。 
        每次采样更新（比模块更新更快）对应的模块都会从 Out 中获取最新的分音并使用它们来更新一个样本，每个采样一个样本。    
        这是一个基本的单声道加法合成器顶层架构：
    </p>
    <p><d-figure><img src="images/algorithm_1.png" alt="Algorithm 1" width="80%" /></d-figure> </p>

    <p>
        请注意，在释放前一个音符之前可能会按下一个新音符：这被称为在单音合成器上演奏连奏。 
        某些模块可能会专门针对这种情况做出响应。 
        例如，分音发生器可能会逐渐从旧音符滑到新音符，这个过程称为滑音。
    </p>

    <li><b>对分音阵列进行插值</b></li>
    <p> 
        两个参数<d-math>\delta \alpha</d-math>指的是什么呢?
        Algorithm 1 中按采样频率调用函数 OutputSample(...)，但是分音阵列更新函数调用间隔是ticksPerUpdate。
        假如 ticksPerUpdate>1 时候，有一个问题需要考虑：即使分音的幅度和频率发生相对较小的变化，也可能表现为基础声波的突然变化，从而产生咔嗒声。
    </p>

    <p>
        最简单的办法对分音做插值处理。我们用<d-math>A^{(t-1)}</d-math>来表示前一次的各个分音对应幅值，用<d-math>A^{(t)}</d-math>来表示当前的分音各个幅值。
        类似的用<d-math>F^{(t-1)}</d-math>和<d-math>F^{(t)}</d-math>来表示前一次和当前的分音对应的频率。
        对于每个分音<d-math>i</d-math>，我们可以定义<d-math>A_i</d-math>和<d-math>F_i</d-math>分别对应幅度以及频率，
        分别通过<d-math> A_i \leftarrow (1-\delta) * A_i^{(t-1)} + \delta * A_i^{(t)} </d-math> 以及 
        <d-math> F_i \leftarrow (1-\delta) * F_i^{(t-1)} + \delta * F_i^{(t)} </d-math> 进行更新。
        当切换到新的分音阵列<d-math>\delta</d-math> 为0，如果又切换到一个新的阵列，立刻逐步的增加到1。
    </p>
    <p>
        在 Algorithm 1中将参数d-math>\delta</d-math>传给函数 OutputSample(...) 就是要起到这个作用。
        注意，我发现用指数曲线比线性增长更容易消除咔嗒，因此要使用指数增长变化。
        但是<d-math>\alpha</d-math>需要设置好，当函数ticksPerUpdate周期到的时候，<d-math>\delta</d-math>至少要满足，大概设置为0.97左右。
    </p>

    <p>
        <b>注意</b> ，<d-math>A^{(t)}</d-math>为0时，插值将推动<d-math>A_i</d-math>逼近<d-math>A^{(t)}</d-math>，你会发现<d-math>A_i</d-math>
        总是停留在极小的浮点小数范围内，对很多编程语言来说，计算这些极小的浮点数是很慢的。
        你需要检测来是否解决这些极小值，并且将 <d-math>A^{(t)}</d-math> 设置为0。
        例如，假如 <d-math>A_i^{(t)} \le s </d-math> 并且 <d-math>\delta \le s</d-math>，s 比极小值稍大一些，那么直接设置<d-math>A_i</d-math>为0。
    </p>

    <li><b>使用分音的阵列生成声音样本</b></li>
    <p>
        在加法合成器的最后，我们必须使用最终的分音阵列，生成声音的样本。我们用死一个四元组来定义一个分音 <d-math>(i,f,a,p)</d-math>:
    </p>

    <ol>
        <li>
            每一个分音有一个唯一的标识 <d-math>i \in 0..N </d-math>。这表示负责输出该部分的正弦波发生器。
            假如分音在阵列中位置不会发生改变，那就直接使用序号i来表示这个分音即可，不需要采用专门的标识。
            然后再某些对阵列进行重新排列的场合就非常有用，例如某些模块修改了分音对应的频率，并且对阵列的排序进行了调整。
            跟踪最初用于哪个生成器的分音很有帮助，因为如果生成器突然切换到具有不同相位、频率或幅度的不同分音，
            您可能会听到发生器的正弦波突然变化时发出的爆音。
        </li>
        <li>
            分音的频率 f 是相对于正在创建的音符的基本频率：例如，如果正在播放的音符是 A 440，并且 f = 2.0，那么分音的频率是 440 × 2.0 = 880。
        </li>
        <li>
            为了保持简单，我们约定分音的幅度 a >= 0 不能取负值。假如需要你一个“负”的幅度，比如三角波，你可以通过修改相位来达到这个目的。
        </li>
        <li>
            p 表示相位，可以是任何值，不了不增加我们自己的麻烦，严格约束 <d-math>0 \le p \le 2 \pi</d-math>。
        </li>
    </ol>

    <p>
        声音合成组件维护着一组正弦波发生<d-math>G_1...G_N</d-math>。每个发生器都保存又当前的瞬时相位 <d-math>x_i</d-math>。
        我们用<d-math>\Delta t</d-math>来表示两次采样之间的间隔时间，例如，44.1k采样率下的间隔为1/44100秒。
        每个间隔下，各个生成器<d-math>G_i</d-math>，根据ID i找到自己对应的分音四元组 <d-math>(i,f,a,p)</d-math>。
        发生器根据对应的频率，向前增加相位值 <d-math>x_i</d-math> ：
        
        <d-math block="">
            x_i^{(t)} \leftarrow x_i^{(t-1)} + f_i \Delta t 
        </d-math>
    </p>


    <p>
        我们假设我们的波形对应的相位变化周期，xi = 0...1 。
        因为单独一个分音对应的信号是周期的，把 xi 设置为0到1的范围是有帮助的。
        因此，当它大于 1 时，我们只需减去 1 以将其重新封装回该范围。
        这样做一个重要原因是，考虑到计算机的浮点数值精度，高值 xi 将开始出现分辨率问题。
        所以可以这样表示：
       
        <d-math block="">
            x_i^{(t)} \leftarrow (x_i^{(t-1)} + f_i \Delta t ) \, mod \, 1
        </d-math>
    
    </p>

    <p>
        就我们的目的而言，mod 1 与“继续减去 1 直到值在 0...1 范围内，不包括 1”是一样的。
        在 Java 中，x mod 1（对于正 x，这是我们的例子）很容易实现为 x = x - (int) x; 
        一旦对每个 xi 完成此操作，我们只需通过相位调整所有正弦波，将它们乘以它们的幅度，然后将它们相加。
        请记住，正弦波的周期为 0...2π，因此我们需要相应地调整周期范围。 所以最终样本定义为：
        <d-math block="">
            \sum_i sin(2 \pi x_i^{(t)}+p_i) * a_i 
        </d-math>
        
        我们可能会将最终结果与增益（音量）相乘，但是基本内容如此。
    </p>

    <p>
        <b>正弦波近似：</b> 加法合成的最大成本是正弦波的生成和求和。 
        不要使用内置的 sin 函数，它的成本很高。 用一个快速查找表来近似它：  
    </p>

    <p><d-figure><img src="images/algorithm_2_3.png" alt="Algorithm 2&3" width="80%" /></d-figure> </p>
    
    <p>
        为了得到更高的精度，我们可以采用 Catmull-Rom 三次样条插值算法，分别取 f(x1),f(x2),f(x3),f(x4)：
        <d-math block="">
            \begin{matrix}
            \alpha &amp; = x * \frac{2^n}{2\pi} - \lfloor {x*\frac{2^n}{2\pi}} \rfloor \\
            f(x_1) &amp; = S_{(i-1\,mod\,2^n)} \\
            f(x_2) &amp; = S_{(i\,mod\,2^n)} \\
            f(x_3) &amp; = S_{(i+1\,mod\,2^n)} \\
            f(x_4) &amp; = S_{(i+2\,mod\,2^n)} \\
            \end{matrix}
        </d-math>
        然后应用 Catmull-Rom，并返回 f(x)。 比直接查表稍慢，但仍比内置的 sin 函数快得多。
    </p>

    <li><b>缓冲和延时</b></li>
    
    <p>
        这是需要注意的重要实现细节。 
        在大多数操作系统中，我们将通过将数据转储到缓冲区来输出声音。 
        我们可以一次转储一个样本中，或者（更有效地）一次将一个样本数组转储。 
        操作系统不能完全耗尽缓冲区，否则它将开始发出垃圾（通常是零）作为声音，因为它没有其他可用的东西。 
        我们必须使此缓冲区足够满，以免发生这种情况。
    </p>

    <p>
        问题是操作系统不会一次只消耗缓冲区一个字节：相反，它会断断续续地从缓冲区中取出块数据。 
        这意味着我们始终必须将缓冲区填充到超过可能的最大块。 
        不同的操作系统和库具有不同的块大小。 
        例如，OS X（我熟悉的）上的 Java 有一个古老的音频工具，它需要大约 1.5K 字节的缓冲区大小。 
        Linux 的低延迟版本可以将其减少到 512 字节或更少。
    </p>

    <p>
        因为保持缓冲区充满声音意味着您在音频中有很多延迟，所以我们希望缓冲区尽可能小。
        也就是说，如果您必须保持 1.5K 缓冲区已满，这将导致高达 17 毫秒的音频延迟，这是一个比较大的延迟！
    </p>

    <li><b>Timing</b></li>

    <p>
        如何确保定期且一致地调用 Tick(...) 方法？ 
        有多种方法：可以使用操作系统提供的计时代码，或轮询 getTime(...) 方法并在适当时调用 Tick(...)。 
        但是有一个更简单的方法：只依赖音频输出缓冲区。 
        也就是说，如果缓冲区未满，则填充它，并且每次用样本填充它时，都调用 Tick(...) 一次。 
        如前所述，缓冲区会时断时续地耗尽，因此您的填充也会断断续续：
        但这并不重要：重要的是所有时间敏感代码都与音频输出同步。 所以直接基于输出本身！
        也就是说，我们会在一个紧密的循环中一遍又一遍地调用以下内容：
    </p>

    <p><d-figure><img src="images/algorithm_4.png" alt="Algorithm 4" width="80%" /></d-figure> </p>

</d-article>

<d-appendix> 
    <d-footnote-list></d-footnote-list>    
    <d-citation-list></d-citation-list>       
</d-appendix>

<distill-footer></distill-footer>

</body>